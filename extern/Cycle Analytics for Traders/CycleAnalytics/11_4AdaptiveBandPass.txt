{
Adaptive BandPass Indicator
(c) 2013 John F. Ehlers
}
Inputs:
	Bandwidth(.3);
Vars:
	AvgLength(3),
	M(0),
	N(0),
	X(0),
	Y(0),
	alpha1(0),
	HP(0),
	a1(0),
	b1(0),
	c1(0),
	c2(0),
	c3(0),
	Filt(0),
	Lag(0),
	count(0),
	Sx(0),
	Sy(0),
	Sxx(0),
	Syy(0),
	Sxy(0),
	Period(0),
	Sp(0),
	Spx(0),
	MaxPwr(0),
	DominantCycle(0);

Arrays:
	Corr[48](0),
	CosinePart[48](0),
	SinePart[48](0),
	SqSum[48](0),
	R[48, 2](0),
	Pwr[48](0);

//Highpass filter cyclic components whose periods are shorter than 48 bars
alpha1 = (Cosine(.707*360 / 48) + Sine (.707*360 / 48) - 1) / Cosine(.707*360 / 48);
HP = (1 - alpha1 / 2)*(1 - alpha1 / 2)*(Close - 2*Close[1] + Close[2]) + 2*(1 - alpha1)*HP[1] - (1 - alpha1)*(1 - alpha1)*HP[2];
//Smooth with a Super Smoother Filter from equation 3-3
a1 = expvalue(-1.414*3.14159 / 10);
b1 = 2*a1*Cosine(1.414*180 / 10);
c2 = b1;
c3 = -a1*a1;
c1 = 1 - c2 - c3;
Filt = c1*(HP + HP[1]) / 2 + c2*Filt[1] + c3*Filt[2];
//Pearson correlation for each value of lag
For Lag = 0 to 48 Begin
	//Set the averaging length as M
	M = AvgLength;
	If AvgLength = 0 Then M = Lag;
	Sx = 0;
	Sy = 0;
	Sxx = 0;
	Syy = 0;
	Sxy = 0;
	For count = 0 to M - 1 Begin
		X = Filt[count];
		Y = Filt[Lag + count];
		Sx = Sx + X;
		Sy = Sy + Y;
		Sxx = Sxx + X*X;
		Sxy = Sxy + X*Y;
		Syy = Syy + Y*Y;
	End;
	If (M*Sxx - Sx*Sx)*(M*Syy - Sy*Sy) > 0 Then Corr[Lag] = (M*Sxy - Sx*Sy)/SquareRoot((M*Sxx - Sx*Sx)*(M*Syy - Sy*Sy));
End;
For Period = 10 to 48 Begin
	CosinePart[Period] = 0;
	SinePart[Period] = 0;
	For N = 3 to 48 Begin
		CosinePart[Period] = CosinePart[Period] + Corr[N]*Cosine(360*N / Period);
		SinePart[Period] = SinePart[Period] + Corr[N]*Sine(360*N / Period);
	End;
	SqSum[Period] = CosinePart[Period]*CosinePart[Period] + SinePart[Period]*SinePart[Period];
End;
For Period = 10 to 48 Begin
	R[Period, 2] = R[Period, 1];
	R[Period, 1] = .2*SqSum[Period]*SqSum[Period] + .8*R[Period, 2];
End;
//Find Maximum Power Level for Normalization
MaxPwr = .995*MaxPwr;
For Period = 10 to 48 Begin
	If R[Period, 1] > MaxPwr Then MaxPwr = R[Period, 1];
End;
For Period = 3 to 48 Begin
	Pwr[Period] = R[Period, 1] / MaxPwr;
End;
//Compute the dominant cycle using the CG of the spectrum
Spx = 0;
Sp = 0;
For Period = 10 to 48 Begin
	If Pwr[Period] >= .5 Then Begin
		Spx = Spx + Period*Pwr[Period];
		Sp = Sp + Pwr[Period];
	End;
End;
If Sp <> 0 Then DominantCycle = Spx / Sp;
If DominantCycle < 10 Then DominantCycle = 10;

//Adaptive BandPass indicator tunes a BandPass filter to 90% of the period of the Dominant Cycle
Vars:
	gamma1(0),
	alpha2(0),
	beta1(0),
	BP(0),
	Peak(0),
	Signal(0),
	Lead(0),
	LeadPeak(0),
	LeadSignal(0);
	
beta1 = Cosine(360 / (.9*DominantCycle));
gamma1 = 1 / Cosine(360*Bandwidth / (.9*DominantCycle));
alpha2 = gamma1 - SquareRoot(gamma1*gamma1 - 1);
BP = .5*(1 - alpha2)*(Filt - Filt[2]) + beta1*(1 + alpha2)*BP[1] - alpha2*BP[2];
If Currentbar = 1 or CurrentBar = 2 Then BP = 0;
Peak = .991*Peak[1];
If AbsValue(BP) > Peak Then Peak = AbsValue(BP);
If Peak <> 0 Then Signal = BP / Peak;
Lead = 1.3*(Signal + Signal[1] - Signal[2] - Signal[3]) / 4;
LeadPeak = .93*LeadPeak[1];
If AbsValue(Lead) > LeadPeak Then LeadPeak = Absvalue(Lead);
If LeadPeak <> 0 Then LeadSignal = .7*Lead / LeadPeak;

Plot1(Signal);
Plot14(.9*Signal[1]);
Plot2(0);
Plot6(.707);
Plot10(-.707);
